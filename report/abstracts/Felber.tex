Development of applications for distributed systems is notoriously complex as one has to deal with various problems such as partial failures, concurrency, remote interactions, synchronization, etc. To capture this complexity and simplify the task of the programmer, it is tempting to develop new languages and tools tailored for distributed systems. But do we really need new languages?
Our experience in designing such a high-level framework revealed that, while one can indeed hide much of the complexity of distributed systems, the programmer is still exposed to it for critical performance optimizations or in some corner cases. Furthermore, given the wide diversity of distributed programs ranging from simple client-server applications to large-scale peer-to-peer networks or stream-oriented systems, it is illusory to believe that a single dedicated language can satisfactorily target all domains.
Instead, a more attractive alternative is to allow multiple languages to seamlessly co-exist in a distrusted system. Each component can be developed with the language most appropriate to the task, and software components can be packaged in micro-services, typically deployed within containers and interacting with one another through standard REST interface. As a consequence, one can provide efficient implementations by developing each component with the best language. The key remaining issue is to properly deploy and “orchestrate” the interactions between these components.
